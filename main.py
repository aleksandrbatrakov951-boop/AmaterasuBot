import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes
import json
import os
from datetime import datetime

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

# === –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ===

# –¢–æ–∫–µ–Ω –±–æ—Ç–∞
BOT_TOKEN = "8315624829:AAFy9oynE5bC12uX4cDkDdyRRwYVB5Hryn4"

# ID –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤
ADMIN_IDS = [8004182708, 7725062904]

# –§–∞–π–ª –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤–æ–ø—Ä–æ—Å–æ–≤
QUESTIONS_FILE = "questions.json"

# === –ö–û–ù–ï–¶ –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–ò ===

class QuestionBot:
    def __init__(self):
        self.questions = self.load_questions()
    
    def load_questions(self):
        if os.path.exists(QUESTIONS_FILE):
            with open(QUESTIONS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {}
    
    def save_questions(self):
        with open(QUESTIONS_FILE, 'w', encoding='utf-8') as f:
            json.dump(self.questions, f, ensure_ascii=False, indent=2)
    
    def add_question(self, question_id, user_id, username, question_text):
        self.questions[question_id] = {
            'user_id': user_id,
            'username': username,
            'question': question_text,
            'status': 'new',
            'admin_id': None,
            'answer': None,
            'timestamp': datetime.now().isoformat()
        }
        self.save_questions()
    
    def update_question_status(self, question_id, status, admin_id=None, answer=None):
        if question_id in self.questions:
            self.questions[question_id]['status'] = status
            if admin_id:
                self.questions[question_id]['admin_id'] = admin_id
            if answer:
                self.questions[question_id]['answer'] = answer
            self.save_questions()

question_bot = QuestionBot()

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    keyboard = [
        [InlineKeyboardButton("üìù –ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å", callback_data="ask_question")],
        [InlineKeyboardButton("‚ÑπÔ∏è –ü–æ–º–æ—â—å", callback_data="help")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        f"–ü—Ä–∏–≤–µ—Ç, {user.first_name}! üëã\n\n"
        "–Ø –±–æ—Ç –¥–ª—è —Å–≤—è–∑–∏ —Å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º–∏.\n"
        "–í—ã –º–æ–∂–µ—Ç–µ –∑–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å, –∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –ø–æ–ª—É—á–∞—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ.",
        reply_markup=reply_markup
    )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    help_text = (
        "ü§ñ **–ü–æ–º–æ—â—å –ø–æ –±–æ—Ç—É**\n\n"
        "üìù **–ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å:**\n"
        "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É '–ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å' –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å –±–æ—Ç—É\n\n"
        "‚ùì **–ß–∞—Å—Ç—ã–µ –≤–æ–ø—Ä–æ—Å—ã:**\n"
        "‚Ä¢ –í–æ–ø—Ä–æ—Å—ã –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –≤ –ø–æ—Ä—è–¥–∫–µ –æ—á–µ—Ä–µ–¥–∏\n"
        "‚Ä¢ –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –æ—Ç–≤–µ—Ç—è—Ç –≤–∞–º –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è\n"
        "‚Ä¢ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ñ–æ—Ä–º—É–ª–∏—Ä—É–π—Ç–µ –≤–æ–ø—Ä–æ—Å—ã —á–µ—Ç–∫–æ –∏ –≤–µ–∂–ª–∏–≤–æ"
    )
    await update.message.reply_text(help_text)

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    user = query.from_user
    data = query.data
    
    if data == "ask_question":
        context.user_data['awaiting_question'] = True
        await query.edit_message_text(
            "üìù **–ó–∞–¥–∞–π—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å:**\n\n"
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–ø–∏—à–∏—Ç–µ –≤–∞—à—É –ø—Ä–æ–±–ª–µ–º—É –∏–ª–∏ –≤–æ–ø—Ä–æ—Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –ø–æ–¥—Ä–æ–±–Ω–æ. "
            "–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä —Å–≤—è–∂–µ—Ç—Å—è —Å –≤–∞–º–∏ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è."
        )
    
    elif data == "help":
        await query.edit_message_text(
            "ü§ñ **–ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º:**\n\n"
            "1. –ù–∞–∂–º–∏—Ç–µ '–ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å'\n"
            "2. –ù–∞–ø–∏—à–∏—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å\n"
            "3. –û–∂–∏–¥–∞–π—Ç–µ –æ—Ç–≤–µ—Ç–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üìù –ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å", callback_data="ask_question")],
                [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="back_to_start")]
            ])
        )
    
    elif data == "back_to_start":
        keyboard = [
            [InlineKeyboardButton("üìù –ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å", callback_data="ask_question")],
            [InlineKeyboardButton("‚ÑπÔ∏è –ü–æ–º–æ—â—å", callback_data="help")]
        ]
        await query.edit_message_text(
            f"–ü—Ä–∏–≤–µ—Ç, {user.first_name}! üëã\n\n"
            "–Ø –±–æ—Ç –¥–ª—è —Å–≤—è–∑–∏ —Å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º–∏.",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    
    elif data.startswith("answer_"):
        question_id = data.split("_")[1]
        context.user_data['answering_question'] = question_id
        await query.edit_message_text(
            f"üí¨ **–í–≤–µ–¥–∏—Ç–µ –æ—Ç–≤–µ—Ç –Ω–∞ –≤–æ–ø—Ä–æ—Å #{question_id}:**"
        )

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    message_text = update.message.text
    
    if context.user_data.get('awaiting_question'):
        context.user_data['awaiting_question'] = False
        
        question_id = str(len(question_bot.questions) + 1).zfill(3)
        
        question_bot.add_question(
            question_id=question_id,
            user_id=user.id,
            username=user.username or user.first_name,
            question_text=message_text
        )
        
        await update.message.reply_text(
            f"‚úÖ **–í–æ–ø—Ä–æ—Å #{question_id} –ø—Ä–∏–Ω—è—Ç!**\n\n"
            f"–í–∞—à –≤–æ–ø—Ä–æ—Å: _{message_text}_\n\n"
            "–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã —É–≤–µ–¥–æ–º–ª–µ–Ω—ã –∏ –æ—Ç–≤–µ—Ç—è—Ç –≤–∞–º –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è.",
            parse_mode='Markdown'
        )
        
        await notify_admins(update, context, question_id, user, message_text)
        
    elif context.user_data.get('answering_question'):
        question_id = context.user_data['answering_question']
        admin_response = message_text
        
        if question_id in question_bot.questions:
            question_data = question_bot.questions[question_id]
            
            question_bot.update_question_status(
                question_id=question_id,
                status='answered',
                admin_id=user.id,
                answer=admin_response
            )
            
            try:
                await context.bot.send_message(
                    chat_id=question_data['user_id'],
                    text=f"üíå **–û—Ç–≤–µ—Ç –Ω–∞ –≤–∞—à –≤–æ–ø—Ä–æ—Å #{question_id}:**\n\n"
                         f"{admin_response}\n\n"
                         f"_–û—Ç–≤–µ—Ç –æ—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞_",
                    parse_mode='Markdown'
                )
                await update.message.reply_text(f"‚úÖ –û—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é!")
            except Exception as e:
                await update.message.reply_text(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–≤–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é: {e}")
            
            context.user_data.pop('answering_question', None)
    
    else:
        keyboard = [[InlineKeyboardButton("üìù –ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å", callback_data="ask_question")]]
        await update.message.reply_text(
            "–ù–∞–ø–∏—à–∏—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å, –∏ —è –ø–µ—Ä–µ–¥–∞–º –µ–≥–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º!",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

async def notify_admins(update: Update, context: ContextTypes.DEFAULT_TYPE, question_id: str, user, question_text: str):
    keyboard = [
        [InlineKeyboardButton("üìù –û—Ç–≤–µ—Ç–∏—Ç—å", callback_data=f"answer_{question_id}")]
    ]
    
    message_text = (
        f"üÜï **–ù–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å #{question_id}**\n\n"
        f"üë§ **–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:** {user.first_name} (@{user.username or 'N/A'})\n"
        f"üÜî **ID:** {user.id}\n\n"
        f"üìù **–í–æ–ø—Ä–æ—Å:**\n{question_text}"
    )
    
    for admin_id in ADMIN_IDS:
        try:
            await context.bot.send_message(
                chat_id=admin_id,
                text=message_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='Markdown'
            )
        except Exception as e:
            logging.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–≤–µ–¥–æ–º–∏—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ {admin_id}: {e}")

async def admin_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    if user_id not in ADMIN_IDS:
        await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.")
        return
    
    total_questions = len(question_bot.questions)
    new_questions = len([q for q in question_bot.questions.values() if q['status'] == 'new'])
    answered_questions = len([q for q in question_bot.questions.values() if q['status'] == 'answered'])
    
    stats_text = (
        f"üìä **–ü–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞**\n\n"
        f"‚Ä¢ –í—Å–µ–≥–æ –≤–æ–ø—Ä–æ—Å–æ–≤: {total_questions}\n"
        f"‚Ä¢ –ù–æ–≤—ã—Ö: {new_questions}\n"
        f"‚Ä¢ –û—Ç–≤–µ—á–µ–Ω–Ω—ã—Ö: {answered_questions}"
    )
    
    await update.message.reply_text(stats_text, parse_mode='Markdown')

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    if user_id not in ADMIN_IDS:
        await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.")
        return
    
    total = len(question_bot.questions)
    new = len([q for q in question_bot.questions.values() if q['status'] == 'new'])
    answered = len([q for q in question_bot.questions.values() if q['status'] == 'answered'])
    
    stats_text = (
        f"üìà **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≤–æ–ø—Ä–æ—Å–æ–≤**\n\n"
        f"‚Ä¢ –í—Å–µ–≥–æ: {total}\n"
        f"‚Ä¢ –û–∂–∏–¥–∞—é—Ç –æ—Ç–≤–µ—Ç–∞: {new}\n"
        f"‚Ä¢ –û—Ç–≤–µ—á–µ–Ω–æ: {answered}\n"
        f"‚Ä¢ –ü—Ä–æ—Ü–µ–Ω—Ç –æ—Ç–≤–µ—Ç–æ–≤: {answered/max(total,1)*100:.1f}%"
    )
    
    await update.message.reply_text(stats_text, parse_mode='Markdown')

def main():
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
    print("=" * 50)
    print("ü§ñ –ë–û–¢ –î–õ–Ø –°–í–Ø–ó–ò –° –ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–û–†–ê–ú–ò")
    print("=" * 50)
    print("‚úÖ –¢–æ–∫–µ–Ω –±–æ—Ç–∞: –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    print(f"‚úÖ –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã: {len(ADMIN_IDS)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
    print(f"   - ID: {ADMIN_IDS[0]}")
    print(f"   - ID: {ADMIN_IDS[1]}")
    print("=" * 50)
    print("–ë–æ—Ç –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è...")
    
    application = Application.builder().token(BOT_TOKEN).build()
    
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("admin", admin_command))
    application.add_handler(CommandHandler("stats", stats_command))
    application.add_handler(CallbackQueryHandler(button_handler))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    
    application.run_polling()

if __name__ == '__main__':
    main()